From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Sat, 4 Apr 2020 15:27:44 -0700
Subject: [PATCH] Allow controlled flushing for network manager

Only make one flush call when emptying the packet queue too

This patch will be used to optimise out flush calls in later
patches.

diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 77aa911c9830170b9f4b5cdf4e0ee2d4ae0d9a99..005f955cd4db5252ab2a7ed387b4dd91132bc03f 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -166,7 +166,13 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
     public void sendPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
         if (this.isConnected() && this.sendPacketQueue() && !(packet instanceof PacketPlayOutMapChunk && !((PacketPlayOutMapChunk) packet).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the packet queue contains chunk packets which are not ready to the packet queue and send the packets later in the right order
             //this.o(); // Paper - Async-Anti-Xray - Move to if statement (this.sendPacketQueue())
+            // Tuinity start - controlled flushing
+            if (this.canFlush && this.packetQueue.isEmpty()) {
             this.b(packet, genericfuturelistener);
+            } else {
+                this.packetQueue.add(new NetworkManager.QueuedPacket(packet, genericfuturelistener));
+            }
+            // Tuinity end - controlled flushing
         } else {
             this.packetQueue.add(new NetworkManager.QueuedPacket(packet, genericfuturelistener));
         }
@@ -175,6 +181,11 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
 
     private void dispatchPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericFutureListener) { this.b(packet, genericFutureListener); } // Paper - OBFHELPER
     private void b(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
+        // Tuinity start - add flush parameter
+        this.writePacket(packet, genericfuturelistener, true);
+    }
+    private final void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, boolean flush) {
+        // Tuinity end - add flush parameter
         EnumProtocol enumprotocol = EnumProtocol.a(packet);
         EnumProtocol enumprotocol1 = (EnumProtocol) this.channel.attr(NetworkManager.c).get();
 
@@ -191,7 +202,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                 this.setProtocol(enumprotocol);
             }
 
-            ChannelFuture channelfuture = (extraPackets == null || extraPackets.isEmpty()) ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Tuinity - make only one flush call for writing packets
+            ChannelFuture channelfuture = (flush && (extraPackets == null || extraPackets.isEmpty())) ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Tuinity - make only one flush call for writing packets // Tuinity - add flush parameter
 
             if (genericfuturelistener != null) {
                 channelfuture.addListener(genericfuturelistener);
@@ -204,7 +215,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                     // note: don't add the genericfuturelistener, it's only expected to be called once...
                     this.channel.write(extraPacket).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
                 }
-                this.channel.flush();
+                if (flush) this.channel.flush(); // Tuinity - add flush parameter
             }
             // Tuinity end - make only one flush call for writing packets
         } else {
@@ -213,7 +224,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                     this.setProtocol(enumprotocol);
                 }
 
-                ChannelFuture channelfuture1 = (extraPackets == null || extraPackets.isEmpty()) ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Tuinity - make only one flush call for writing packets
+                ChannelFuture channelfuture1 = (flush && (extraPackets == null || extraPackets.isEmpty())) ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Tuinity - make only one flush call for writing packets // Tuinity - add flush parameter
 
                 if (genericfuturelistener != null) {
                     channelfuture1.addListener(genericfuturelistener);
@@ -226,7 +237,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                         // note: don't add the genericfuturelistener, it's only expected to be called once...
                         this.channel.write(extraPacket).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
                     }
-                    this.channel.flush();
+                    if (flush) this.channel.flush(); // Tuinity - add flush parameter
                 }
                 // Tuinity end - make only one flush call for writing packets
             });
@@ -235,10 +246,35 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
 
     }
 
+    // Tuinity start - only make one flush call per sendPacketQueue() call
+    volatile boolean canFlush = true;
+
+    void disableAutomaticFlush() {
+        this.canFlush = false;
+    }
+
+    void enableAutomaticFlush() {
+        this.canFlush = true;
+        this.sendPacketQueue(); // note: this must be after the canFlush write
+    }
+
+    private final void flush() {
+        if (this.canFlush) {
+            if (this.channel.eventLoop().inEventLoop()) {
+                this.channel.flush();
+            } else {
+                this.channel.eventLoop().execute(() -> {
+                    this.channel.flush();
+                });
+            }
+        }
+    }
+    // Tuinity end - only make one flush call per sendPacketQueue() call
+
     // Paper start - Async-Anti-Xray - Stop dispatching further packets and return false if the peeked packet is a chunk packet which is not ready
     private boolean sendPacketQueue() { return this.o(); } // OBFHELPER // void -> boolean
     private boolean o() { // void -> boolean
-        if (this.channel != null && this.channel.isOpen()) {
+        if (this.channel != null && this.channel.isOpen() && this.canFlush) { // Tuinity - let packets build up for the following sendPacketQueue when canFlush is set to true
             Queue queue = this.packetQueue;
 
             synchronized (this.packetQueue) {
@@ -250,10 +286,13 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                             return false; // Return false if the peeked packet is a chunk packet which is not ready
                         } else {
                             this.getPacketQueue().poll(); // poll here
-                            this.dispatchPacket(networkmanager_queuedpacket.getPacket(), networkmanager_queuedpacket.getGenericFutureListener()); // dispatch the packet
+                            this.writePacket(networkmanager_queuedpacket.getPacket(), networkmanager_queuedpacket.getGenericFutureListener(), false); // dispatch the packet // Tuinity - only make one flush call per sendPacketQueue() call
                         }
                     }
                 }
+                // Tuinity start - only make one flush call per sendPacketQueue() call
+                this.flush();
+                // Tuinity end - only make one flush call per sendPacketQueue() call
 
             }
         }
